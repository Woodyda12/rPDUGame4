<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Glider – Design for Cost Edition</title>
    <style>
        /* ==== General page styles ======================================= */
        html, body {
          margin: 0;
          padding: 0;
          height: 100%;
          overflow: hidden;        /* no scrollbars */
          background: #000;        /* deep black for neon contrast */
          font-family: sans-serif;
        }
        /* ===== WebGL canvas (auto-inserted by Three.js) ================= */
        canvas {
          display: block;          /* removes small gaps below canvas */
        }
        /* ===== Score display =========================================== */
        #score {
          position: fixed;
          top: 10px;
          left: 10px;
          font: bold 18px sans-serif;
          color: #00ff00;          /* neon green */
          z-index: 11;
          user-select: none;
        }
        /* ===== Game-Over overlay ======================================= */
        #overlay {
          position: fixed;
          inset: 0;                         /* top/right/bottom/left = 0 */
          background: rgba(0, 0, 0, 0.85);  /* darker translucent black */
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 100;                     /* higher z-index */
          color: #ff3366;                   /* neon magenta text */
          font: bold 32px/1.3 sans-serif;
          text-align: center;
        }
        .hidden { 
          display: none !important;         /* force hide with !important */
        }

        /* Loading indicator */
        #loading {
          position: fixed;
          inset: 0;
          background: #000;
          display: flex;
          align-items: center;
          justify-content: center;
          color: #00ff00;
          font: bold 24px sans-serif;
          z-index: 20;
        }

        /* Instructions */
        #instructions {
          position: fixed;
          bottom: 20px;
          left: 20px;
          color: #00ff00;
          font: 14px sans-serif;
          z-index: 11;
          user-select: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="loading">Loading Grid Glider...</div>
    <div id="overlay" class="hidden">
        <div id="gameOverText">Game Over<br>Press R to Restart</div>
    </div>
    <div id="score">Score: 0</div>
    <div id="instructions">Use Arrow Keys or A/D to move • R to restart</div>
    
    <script>
        /*  Grid Glider – Design for Cost Edition
            Complete game logic – Three.js endless-runner
        --------------------------------------------------------------------*/

        // ----- Global state ------------------------------------------------
        let scene, camera, renderer;
        let player;
        let obstacles = [];
        let obstacleTextures = [];        // loaded PNGs
        let texturesLoaded = false;
        const laneX = [-4, -2, 0, 2, 4];  // 5-lane grid
        let currentLane = 2;              // start in centre lane

        let clock;                        // Three.js clock
        let score = 0;
        let speed = 0.10;                 // base forward speed
        let gameOver = false;
        let gameStarted = false;

        // ----- UI elements -------------------------------------------------
        const scoreDiv = document.getElementById('score');
        const overlay  = document.getElementById('overlay');
        const loading  = document.getElementById('loading');

        // ----- Fallback colors for obstacles -------------------------------
        const obstacleColors = [
            0xff0000, // red
            0xff6600, // orange
            0xffff00, // yellow
            0xff00ff, // magenta
            0x00ffff  // cyan
        ];

        // ------------------------------------------------------------------
        //  Load textures with fallback
        // ------------------------------------------------------------------
        function loadTextures() {
            return new Promise((resolve) => {
                const loader = new THREE.TextureLoader();
                let loadedCount = 0;
                const totalTextures = 5;
                
                for (let i = 1; i <= totalTextures; i++) {
                    loader.load(
                        `assets/obstacle${i}.png`,
                        // Success callback
                        (texture) => {
                            obstacleTextures.push(texture);
                            loadedCount++;
                            console.log(`Loaded obstacle${i}.png`);
                            
                            if (loadedCount === totalTextures) {
                                texturesLoaded = true;
                                console.log('All textures loaded successfully');
                                resolve();
                            }
                        },
                        // Progress callback
                        undefined,
                        // Error callback
                        (error) => {
                            console.warn(`Failed to load assets/obstacle${i}.png:`, error);
                            loadedCount++;
                            
                            if (loadedCount === totalTextures) {
                                console.log('Some textures failed to load, using fallback colors');
                                resolve();
                            }
                        }
                    );
                }
            });
        }

        // ------------------------------------------------------------------
        //  Initialisation
        // ------------------------------------------------------------------
        async function init() {
            try {
                // Load textures first
                await loadTextures();

                // Scene & camera
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.set(0, 5, 10);
                camera.lookAt(0, 0, 0);

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x111111); // lighter background
                document.body.appendChild(renderer.domElement);

                // Brighter lighting
                const ambient = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambient);

                const directional = new THREE.DirectionalLight(0xffffff, 0.6);
                directional.position.set(0, 10, 5);
                scene.add(directional);

                // Brighter grid floor
                const grid = new THREE.GridHelper(100, 20, 0x00ff88, 0x00ff88);
                grid.position.y = 0;
                scene.add(grid);

                // Player mesh - brighter
                const playerGeom = new THREE.BoxGeometry(1, 1, 1);
                const playerMat = new THREE.MeshStandardMaterial({
                    color: 0x00ffaa,
                    emissive: 0x00ffaa,
                    emissiveIntensity: 0.4
                });
                player = new THREE.Mesh(playerGeom, playerMat);
                player.position.set(laneX[currentLane], 0.5, 0);
                scene.add(player);

                // Handle window resizing
                window.addEventListener('resize', onWindowResize);

                // Input handling
                window.addEventListener('keydown', handleKeyDown);

                // Start clock
                clock = new THREE.Clock();

                // Hide loading screen
                loading.style.display = 'none';
                
                // Start the game
                startGame();

                console.log('Grid Glider initialized successfully!');

            } catch (error) {
                console.error('Error initializing game:', error);
                loading.innerHTML = 'Error loading game. Please refresh the page.';
            }
        }

        // ------------------------------------------------------------------
        //  Start the game
        // ------------------------------------------------------------------
        function startGame() {
            gameStarted = true;
            spawnObstacle();
            animate();
        }

        // ------------------------------------------------------------------
        //  Input
        // ------------------------------------------------------------------
        function handleKeyDown(e) {
            // Restart if game over
            if (gameOver && (e.key.toLowerCase() === 'r' || e.code === 'KeyR')) {
                resetGame();
                return;
            }

            // Ignore other keys when game over or not started
            if (gameOver || !gameStarted) return;

            // Move left / right
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                currentLane = Math.max(0, currentLane - 1);
                player.position.x = laneX[currentLane];
            }
            if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                currentLane = Math.min(laneX.length - 1, currentLane + 1);
                player.position.x = laneX[currentLane];
            }
        }

        // ------------------------------------------------------------------
        //  Spawn new obstacle
        // ------------------------------------------------------------------
        function spawnObstacle() {
            if (!gameStarted || gameOver) return;

            const size = 1.5;
            const geom = new THREE.BoxGeometry(size, size, size);
            
            let mat;
            
            // Use loaded textures if available, otherwise use colors
            if (texturesLoaded && obstacleTextures.length > 0) {
                const texture = obstacleTextures[Math.floor(Math.random() * obstacleTextures.length)];
                mat = new THREE.MeshStandardMaterial({
                    map: texture,
                    emissive: 0x444444,
                    emissiveIntensity: 0.7
                });
            } else {
                // Fallback to colored materials - brighter
                const color = obstacleColors[Math.floor(Math.random() * obstacleColors.length)];
                mat = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.4
                });
            }
            
            const obs = new THREE.Mesh(geom, mat);

            // Position far ahead in random lane
            obs.position.set(
                laneX[Math.floor(Math.random() * laneX.length)],
                size / 2,
                -50
            );

            scene.add(obs);
            obstacles.push(obs);

            // Schedule next obstacle - much faster spawning with progressive speed
            const minDelay = 200; // minimum 0.2 seconds between obstacles
            const maxDelay = 800; // maximum delay
            const speedReduction = Math.min(400, score / 20); // reduce delay based on score
            const baseDelay = Math.max(minDelay, maxDelay - speedReduction);
            const delay = baseDelay + Math.random() * 200;
            setTimeout(spawnObstacle, delay);
        }

        // ------------------------------------------------------------------
        //  Game loop
        // ------------------------------------------------------------------
        function animate() {
            requestAnimationFrame(animate);

            if (!gameStarted) return;

            const delta = clock.getDelta();

            if (!gameOver) {
                // Move obstacles towards camera
                obstacles.forEach(o => { 
                    o.position.z += speed;
                    // Add some rotation for visual interest
                    o.rotation.x += delta * 2;
                    o.rotation.y += delta * 1.5;
                });

                // Remove passed obstacles
                obstacles = obstacles.filter(o => {
                    if (o.position.z > camera.position.z + 5) {
                        scene.remove(o);
                        return false;
                    }
                    return true;
                });

                // Collision check - more precise
                obstacles.forEach(o => {
                    const playerBounds = {
                        x: player.position.x,
                        z: player.position.z,
                        size: 0.8 // slightly smaller than visual for more forgiving gameplay
                    };
                    
                    const obstacleBounds = {
                        x: o.position.x,
                        z: o.position.z,
                        size: 1.2
                    };
                    
                    const distance = Math.sqrt(
                        Math.pow(obstacleBounds.x - playerBounds.x, 2) +
                        Math.pow(obstacleBounds.z - playerBounds.z, 2)
                    );
                    
                    if (distance < (playerBounds.size + obstacleBounds.size) / 2) {
                        gameOver = true;
                        overlay.classList.remove('hidden');
                    }
                });

                // Update score & difficulty - faster progression
                score += delta * 15;                   // 15 pts / sec (faster scoring)
                speed = Math.min(0.35, 0.12 + (score * 0.0001)); // faster base speed, higher cap
                scoreDiv.textContent = `Score: ${Math.floor(score)}`;
            }

            renderer.render(scene, camera);
        }

        // ------------------------------------------------------------------
        //  Reset after crash
        // ------------------------------------------------------------------
        function resetGame() {
            // Clear existing obstacles
            obstacles.forEach(o => scene.remove(o));
            obstacles.length = 0;

            // Reset state
            score = 0;
            speed = 0.12; // faster starting speed
            currentLane = 2;
            player.position.x = laneX[currentLane];
            gameOver = false;
            overlay.classList.add('hidden'); // ensure overlay is hidden

            // Reset clock & start new obstacle stream
            clock.start();
            spawnObstacle();
        }

        // ------------------------------------------------------------------
        //  Utilities
        // ------------------------------------------------------------------
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ------------------------------------------------------------------
        //  Initialize when page loads
        // ------------------------------------------------------------------
        window.addEventListener('load', init);

        // Fallback initialization after short delay
        setTimeout(() => {
            if (!gameStarted && !scene) {
                init();
            }
        }, 1000);
    </script>
</body>
</html>
